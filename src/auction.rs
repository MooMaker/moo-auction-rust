use std::collections::HashMap;

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Bid {
    pub bidder_id: String,
    pub amount: u64,
}

#[derive(Default, Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Auction {
    pub auction_id: String,
    pub time_limit: u64,
    pub bids: Vec<Bid>,
    pub tokens: HashMap<String, Token>,
    pub orders: HashMap<u64, Order>,
    pub amms: HashMap<u64, Amm>,
    pub metadata: Metadata,
}

impl MooAuction {
    pub fn new(auction_id: String, time_limit: u64) -> Self {
        Self {
            auction_id,
            time_limit,
            bids: Vec::new(),
            tokens: HashMap::new(),
            orders: HashMap::new(),
            amms: HashMap::new(),
            metadata: Metadata::default(),
        }
    }

    pub fn add_bid(&mut self, bidder_id: String, amount: u64) {
        let bid = Bid {
            bidder_id,
            amount,
        };

        self.bids.push(bid);
    }

    pub 


    // Add more methods as needed for bid validation, handling time limit, etc.
}




Id: (order id. Solver in our implementation needs to increment it by one each time he requests quotes from makers)
tokenIn: (address of token makers receive)
tokenOut:  (address of token makers give in return)
Amountin: (in wei)
Amount out: (in wei)
validTo: 1628035200 (let's set it always to current time+30 seconds for hackathon although ideally it should be adjusted as per auction timing. Normally makers would not support quote longer than 1-3 seconds)
Makeraddress: (crypro address of maker)
MakerSignature: 0xea2ba7a7a8fc1c0ef93aec9833fde9f8bd425ddec45090cdd0c86a1bc75dd0f825e2a3e978d46a18f5ea9a61c09d52849d547c0f41ca6fae7480835307352a241b (pre generated by maker through calling smart contrac function for signature generation which I will add soon)




pub fn compare_solution(solution_json: String) {
    //TODO get best solution from storage
    let mut best_solution = "{}";
    if compute_value(solution_json) > compute_value(best_solution) {
        best_solution = solution_json;
    }
}

fn compute_value(solution_json: String) -> f64 {
    return 0.0;
}


